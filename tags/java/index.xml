<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on 诗川的笔记</title>
    <link>/tags/java/</link>
    <description>Recent content in Java on 诗川的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>©2020 bluepix</copyright>
    <lastBuildDate>Sat, 04 Apr 2020 10:20:29 +0800</lastBuildDate>
    
        <atom:link href="/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 并发编程问答</title>
      <link>/posts/java-concurrency-q-n-a/</link>
      <pubDate>Sat, 04 Apr 2020 10:20:29 +0800</pubDate>
      
      <guid>/posts/java-concurrency-q-n-a/</guid>
      <description>关于 Java 并发编程的一些问题 (尽可能短) 的回答. Q: 并发编程要什么? A: 并发编程希望得到 安全性 (Safety): 坏事不会发生. 活跃性 (Liveness): 好事终会发生. 高性能 (Performance): 好事快点</description>
      
    </item>
    
    <item>
      <title>[JCIP] 16.Java 内存模型</title>
      <link>/notes/jcip/jcip-16-jmm/</link>
      <pubDate>Fri, 03 Apr 2020 23:21:47 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-16-jmm/</guid>
      <description>什么是内存模型 乱序执行 乱序 (out of order) 执行来源于编译器、运行时和硬件的优化, 例如: 编译器可能产生与程序定义顺序不同的指令序列 可能将变量保存在寄存器</description>
      
    </item>
    
    <item>
      <title>[JCIP] 15.原子变量和非阻塞同步</title>
      <link>/notes/jcip/jcip-15-atomic-nonblocking/</link>
      <pubDate>Fri, 03 Apr 2020 17:36:39 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-15-atomic-nonblocking/</guid>
      <description>原子变量和非阻塞同步 是 Semaphore 等类更好的性能与伸缩性的来源. 非阻塞算法 非阻塞算法使用底层的原子机器指令如 compare-and-swap 代替锁来保证数据在并发访问下的完整性, 广</description>
      
    </item>
    
    <item>
      <title>[JCIP] 14.自定义 Synchronizers</title>
      <link>/notes/jcip/jcip-14-custom-synchronizers/</link>
      <pubDate>Fri, 03 Apr 2020 09:09:45 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-14-custom-synchronizers/</guid>
      <description>Java 类库提供了数个有状态依赖的类 (state-dependent classes), 这些类的某些操作操作要求满足基于状态的前置条件 (state-based preconditions). 如 FutureTask、Semaphore、Blocki</description>
      
    </item>
    
    <item>
      <title>[JCIP] 13.显式锁</title>
      <link>/notes/jcip/jcip-13-explicit-locks/</link>
      <pubDate>Thu, 02 Apr 2020 21:15:03 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-13-explicit-locks/</guid>
      <description>Lock 和 ReentrantLock Lock 接口定义了一些抽象锁操作. 与内置锁相比, Lock 接口提供了多个版本不同特性的锁获取方法, 并且所有的锁与解锁都是显式的. Lock 的实现必须提供与内</description>
      
    </item>
    
    <item>
      <title>[JCIP] 11.性能和伸缩性</title>
      <link>/notes/jcip/jcip-11-perf-n-scal/</link>
      <pubDate>Thu, 02 Apr 2020 14:13:11 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-11-perf-n-scal/</guid>
      <description>使用线程的首要目的是提高性能, 但提高性能的同时也增加了复杂性. 当性能和安全需要冲突时, 应当安全优先. 关于性能优化 提高性能意味着用更少的资源做</description>
      
    </item>
    
    <item>
      <title>[JCIP] 10.避免活跃性风险</title>
      <link>/notes/jcip/jcip-10-avoid-liveness-hazards/</link>
      <pubDate>Thu, 02 Apr 2020 11:40:59 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-10-avoid-liveness-hazards/</guid>
      <description>死锁 最简单的死锁 (deadlock) 是两个线程各自持有对方想要获取的锁, 导致无限等待. 在表示等待关系的图上存在环, 则死锁存在. 数据库系统会检测和恢复事务死锁 (</description>
      
    </item>
    
    <item>
      <title>[JCIP] 09.GUI 应用程序</title>
      <link>/notes/jcip/jcip-09-gui-app/</link>
      <pubDate>Thu, 02 Apr 2020 10:20:18 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-09-gui-app/</guid>
      <description>为什么 GUI 是单线程的 多线程 GUI 极易产生死锁. 死锁的一个可能原因是用户操作和界面响应的处理方向矛盾. 用户的操作事件一般是从 OS 到应用向上传递, 而界面</description>
      
    </item>
    
    <item>
      <title>[JCIP] 08.线程池的应用</title>
      <link>/notes/jcip/jcip-08-thread-pools/</link>
      <pubDate>Wed, 01 Apr 2020 19:59:34 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-08-thread-pools/</guid>
      <description>任务与执行策略的隐含耦合 任务对执行策略的隐含要求 Executor 框架的目的是解耦任务及其执行, 但某些类型的任务需要特定的执行策略: 依赖性任务. 如果提交的任</description>
      
    </item>
    
    <item>
      <title>[JCIP] 07.取消和关闭</title>
      <link>/notes/jcip/jcip-07-cancellation-n-shutdown/</link>
      <pubDate>Wed, 01 Apr 2020 10:09:03 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-07-cancellation-n-shutdown/</guid>
      <description>任务取消 如果一各活动允许外部代码在其正常执行完成之前将其移动到完成状态, 就说这个活动是可取消的 (cancellable). 取消活动的动机可能有: 用户操作取消 时间受限活</description>
      
    </item>
    
    <item>
      <title>[JCIP] 06.任务执行</title>
      <link>/notes/jcip/jcip-06-task-execution/</link>
      <pubDate>Tue, 31 Mar 2020 22:05:14 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-06-task-execution/</guid>
      <description>任务 (Task) 是抽象、离散的工作单元. 将并发程序划分为任务的好处包括: 简化程序结构 提供自然的事务边界, 利于错误恢复 提供自然的并行工作结构边界, 利于提</description>
      
    </item>
    
    <item>
      <title>[JCIP] 05.构造块</title>
      <link>/notes/jcip/jcip-05-building-blocks/</link>
      <pubDate>Tue, 31 Mar 2020 10:09:39 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-05-building-blocks/</guid>
      <description>同步集合类 最初 JDK 中包含的: Vector、 Hashtable JDK 1.2 增加的: 通过 Collections.synchronizedXXX 工厂方法创建的对象 同步策略: 封装所有的状态, 并同步所有的公共方法来保证同一时间只</description>
      
    </item>
    
    <item>
      <title>[JCIP] 04.组合对象</title>
      <link>/notes/jcip/jcip-04-composing-objects/</link>
      <pubDate>Tue, 31 Mar 2020 00:35:34 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-04-composing-objects/</guid>
      <description>设计线程安全的类 虽然可以完全不使用线程安全的类构造线程安全的程序, 但良好的封装是设计线程安全程序的重要方法. 设计线程安全的类一般分三步: 识别</description>
      
    </item>
    
    <item>
      <title>[JCIP] 03.共享对象</title>
      <link>/notes/jcip/jcip-03-sharing-objects/</link>
      <pubDate>Mon, 30 Mar 2020 15:31:24 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-03-sharing-objects/</guid>
      <description>可见性 概念 原子性保证状态正确地转换, 可见性要求状态的转换可以在其它线程观察到. 来源: 编译器、运行时、硬件的优化 (如分支预测执行、内存缓存)等</description>
      
    </item>
    
    <item>
      <title>[JCIP] 02.线程安全</title>
      <link>/notes/jcip/jcip-02-thread-safety/</link>
      <pubDate>Mon, 30 Mar 2020 14:07:36 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-02-thread-safety/</guid>
      <description>问题与解答 问题: 核心是共享可变状态 线程与锁只是通往目的的手段. 编写线程安全代码的核心是: 管理对共享、可变状态的访问. 状态 (State) 非正式的说, 对象的</description>
      
    </item>
    
    <item>
      <title>[JCIP] 00~01.前言和导论</title>
      <link>/notes/jcip/jcip-00-01-intro/</link>
      <pubDate>Mon, 30 Mar 2020 13:53:23 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-00-01-intro/</guid>
      <description>总体思路 机制和规则 机制 (mechanisms): Java 语言为支持并发编程特性提供了各种底层机制, 如同步、条件等; 规则 (policies): Java 编程人员需要的应用程序级别的协议或规则. 底层机制</description>
      
    </item>
    
    <item>
      <title>Java 内存模型入门</title>
      <link>/posts/on-jmm/</link>
      <pubDate>Mon, 16 Mar 2020 08:28:56 +0800</pubDate>
      
      <guid>/posts/on-jmm/</guid>
      <description>引言 Java 内存模型 (Java Memory Model, JMM) 是 Java 并发编程中一个较为底层的话题, Java 并发编程中的各种上层策略, 如安全发布 (Safe publication)、使用同步 (synchronization) 等, 其有</description>
      
    </item>
    
  </channel>
</rss>
