<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>技术 on 诗川的笔记</title>
    <link>/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on 诗川的笔记</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>©2020 bluepix</copyright>
    <lastBuildDate>Fri, 03 Apr 2020 09:09:45 +0800</lastBuildDate>
    
        <atom:link href="/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[JCIP] 14.自定义 Synchronizers</title>
      <link>/notes/jcip/jcip-14-custom-synchronizers/</link>
      <pubDate>Fri, 03 Apr 2020 09:09:45 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-14-custom-synchronizers/</guid>
      <description>Java 类库提供了数个有状态依赖的类 (state-dependent classes), 这些类的某些操作操作要求满足基于状态的前置条件 (state-based preconditions). 如 FutureTask、Semaphore、Blocki</description>
      
    </item>
    
    <item>
      <title>[JCIP] 13.显式锁</title>
      <link>/notes/jcip/jcip-13-explicit-locks/</link>
      <pubDate>Thu, 02 Apr 2020 21:15:03 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-13-explicit-locks/</guid>
      <description>Lock 和 ReentrantLock Lock 接口定义了一些抽象锁操作. 与内置锁相比, Lock 接口提供了多个版本不同特性的锁获取方法, 并且所有的锁与解锁都是显式的. Lock 的实现必须提供与内</description>
      
    </item>
    
    <item>
      <title>[JCIP] 11.性能和伸缩性</title>
      <link>/notes/jcip/jcip-11-perf-n-scal/</link>
      <pubDate>Thu, 02 Apr 2020 14:13:11 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-11-perf-n-scal/</guid>
      <description>使用线程的首要目的是提高性能, 但提高性能的同时也增加了复杂性. 当性能和安全需要冲突时, 应当安全优先. 关于性能优化 提高性能意味着用更少的资源做</description>
      
    </item>
    
    <item>
      <title>[JCIP] 10.避免活跃性风险</title>
      <link>/notes/jcip/jcip-10-avoid-liveness-hazards/</link>
      <pubDate>Thu, 02 Apr 2020 11:40:59 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-10-avoid-liveness-hazards/</guid>
      <description>死锁 最简单的死锁 (deadlock) 是两个线程各自持有对方想要获取的锁, 导致无限等待. 在表示等待关系的图上存在环, 则死锁存在. 数据库系统会检测和恢复事务死锁 (</description>
      
    </item>
    
    <item>
      <title>[JCIP] 09.GUI 应用程序</title>
      <link>/notes/jcip/jcip-09-gui-app/</link>
      <pubDate>Thu, 02 Apr 2020 10:20:18 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-09-gui-app/</guid>
      <description>为什么 GUI 是单线程的 多线程 GUI 极易产生死锁. 死锁的一个可能原因是用户操作和界面响应的处理方向矛盾. 用户的操作事件一般是从 OS 到应用向上传递, 而界面</description>
      
    </item>
    
    <item>
      <title>[JCIP] 08.线程池的应用</title>
      <link>/notes/jcip/jcip-08-thread-pools/</link>
      <pubDate>Wed, 01 Apr 2020 19:59:34 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-08-thread-pools/</guid>
      <description>任务与执行策略的隐含耦合 任务对执行策略的隐含要求 Executor 框架的目的是解耦任务及其执行, 但某些类型的任务需要特定的执行策略: 依赖性任务. 如果提交的任</description>
      
    </item>
    
    <item>
      <title>[JCIP] 07.取消和关闭</title>
      <link>/notes/jcip/jcip-07-cancellation-n-shutdown/</link>
      <pubDate>Wed, 01 Apr 2020 10:09:03 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-07-cancellation-n-shutdown/</guid>
      <description>任务取消 如果一各活动允许外部代码在其正常执行完成之前将其移动到完成状态, 就说这个活动是可取消的 (cancellable). 取消活动的动机可能有: 用户操作取消 时间受限活</description>
      
    </item>
    
    <item>
      <title>[JCIP] 06.任务执行</title>
      <link>/notes/jcip/jcip-06-task-execution/</link>
      <pubDate>Tue, 31 Mar 2020 22:05:14 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-06-task-execution/</guid>
      <description>任务 (Task) 是抽象、离散的工作单元. 将并发程序划分为任务的好处包括: 简化程序结构 提供自然的事务边界, 利于错误恢复 提供自然的并行工作结构边界, 利于提</description>
      
    </item>
    
    <item>
      <title>[JCIP] 05.构造块</title>
      <link>/notes/jcip/jcip-05-building-blocks/</link>
      <pubDate>Tue, 31 Mar 2020 10:09:39 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-05-building-blocks/</guid>
      <description>同步集合类 最初 JDK 中包含的: Vector、 Hashtable JDK 1.2 增加的: 通过 Collections.synchronizedXXX 工厂方法创建的对象 同步策略: 封装所有的状态, 并同步所有的公共方法来保证同一时间只</description>
      
    </item>
    
    <item>
      <title>[JCIP] 04.组合对象</title>
      <link>/notes/jcip/jcip-04-composing-objects/</link>
      <pubDate>Tue, 31 Mar 2020 00:35:34 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-04-composing-objects/</guid>
      <description>设计线程安全的类 虽然可以完全不使用线程安全的类构造线程安全的程序, 但良好的封装是设计线程安全程序的重要方法. 设计线程安全的类一般分三步: 识别</description>
      
    </item>
    
    <item>
      <title>[JCIP] 02.线程安全</title>
      <link>/notes/jcip/jcip-02-thread-safety/</link>
      <pubDate>Mon, 30 Mar 2020 14:07:36 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-02-thread-safety/</guid>
      <description>问题与解答 问题: 核心是共享可变状态 线程与锁只是通往目的的手段. 编写线程安全代码的核心是: 管理对共享、可变状态的访问. 状态 (State) 非正式的说, 对象的</description>
      
    </item>
    
    <item>
      <title>[JCIP] 00~01.前言和导论</title>
      <link>/notes/jcip/jcip-00-01-intro/</link>
      <pubDate>Mon, 30 Mar 2020 13:53:23 +0800</pubDate>
      
      <guid>/notes/jcip/jcip-00-01-intro/</guid>
      <description>总体思路 机制和规则 机制 (mechanisms): Java 语言为支持并发编程特性提供了各种底层机制, 如同步、条件等; 规则 (policies): Java 编程人员需要的应用程序级别的协议或规则. 底层机制</description>
      
    </item>
    
    <item>
      <title>Java 内存模型入门</title>
      <link>/posts/on-jmm/</link>
      <pubDate>Mon, 16 Mar 2020 08:28:56 +0800</pubDate>
      
      <guid>/posts/on-jmm/</guid>
      <description>引言 Java 内存模型 (Java Memory Model, JMM) 是 Java 并发编程中一个较为底层的话题, Java 并发编程中的各种上层策略, 如安全发布 (Safe publication)、使用同步 (synchronization) 等, 其有</description>
      
    </item>
    
    <item>
      <title>[译] 如何制造正确执行多进程程序的多处理器计算机</title>
      <link>/posts/make-mp-computer-correctly/</link>
      <pubDate>Sat, 14 Mar 2020 17:47:46 +0800</pubDate>
      
      <guid>/posts/make-mp-computer-correctly/</guid>
      <description>注： 本文译自 Leslie Lamport 发表于 1979 年 9 月的 IEEE Transactions on Computers 上的文章 How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs, 其重要意义在于正式定义了顺序一致性. Lamport 于 2013 年获图灵奖, 其获奖成就之一就</description>
      
    </item>
    
  </channel>
</rss>
